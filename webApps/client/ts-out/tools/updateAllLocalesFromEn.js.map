{"version":3,"file":"updateAllLocalesFromEn.js","sourceRoot":"","sources":["../../src/tools/updateAllLocalesFromEn.ts"],"names":[],"mappings":"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","sourcesContent":["import { jsonrepair } from \"jsonrepair\";\nimport { OpenAI } from \"openai\";\nimport ISO6391 from \"iso-639-1\";\nimport * as fs from \"fs\";\nimport * as path from \"path\";\nimport { promisify } from \"util\";\n\nconst readFilePromise = promisify(fs.readFile);\nconst writeFilePromise = promisify(fs.writeFile);\n\ninterface Translation {\n  [key: string]: string | Translation; // Allow nested translations\n}\n\nexport class YpLocaleTranslation {\n  openaiClient: OpenAI;\n  modelName = \"gpt-4-0125-preview\";\n  maxTokens = 4000;\n  temperature = 0.0;\n\n  constructor() {\n    this.openaiClient = new OpenAI({\n      apiKey: process.env.OPENAI_API_KEY,\n    });\n  }\n  getValueByPath(obj: any, path: any) {\n    return path.split('.').reduce((acc:any, part: any) => acc && acc[part], obj) || \"\";\n  }\n\n  async loadAndCompareTranslations() {\n    const localesDir = \"./locales\";\n    const baseTranslationPath = path.join(localesDir, \"en/translation.json\");\n    const baseTranslation: Translation = await this.loadJsonFile<Translation>(\n      baseTranslationPath\n    );\n\n    const localeDirs = fs\n      .readdirSync(localesDir)\n      .filter((file) => fs.statSync(path.join(localesDir, file)).isDirectory());\n\n    for (const localeDir of localeDirs) {\n      if (localeDir !== \"is\") continue; // Skip English since it's the base\n\n      console.log(`Processing locale: ${localeDir}`);\n      const translationFilePath = path.join(\n        localesDir,\n        localeDir,\n        \"translation.json\"\n      );\n      let translation: Translation = await this.loadJsonFile<Translation>(\n        translationFilePath\n      );\n      translation = this.updateWithMissingKeys(baseTranslation, translation);\n      console.log(`Updated translation for ${localeDir}:`, translation);\n\n      const missingTranslations = this.extractMissingTranslations(\n        baseTranslation,\n        translation\n      );\n\n      // Chunk the missing translations\n      const chunks = this.chunkArray(missingTranslations, 15);\n\n      console.log(\n        `Missing translations for ${localeDir}:`,\n        missingTranslations,\n        chunks\n      );\n\n      for (const chunk of chunks) {\n        console.log(`Translating chunk: ${JSON.stringify(chunk)}`); // Log the chunk before translation\n\n        // Prepare the texts for translation\n        const textsToTranslate = chunk.map((key) => this.getValueByPath(translation, key));\n\n        // Call your translateUITexts method\n        const translations = await this.translateUITexts(\n          localeDir,\n          textsToTranslate as string[]\n        );\n\n        // Update the translation with the new texts\n        chunk.forEach((key, index) => {\n          if (translations && translations[index]) {\n            this.setValueAtPath(translation, key, translations[index]);\n          }\n        });\n\n        console.log(`Chunk after translation: ${JSON.stringify(chunk)}`); // Log the chunk after translation\n\n        console.log(`Updated translation for ${localeDir}:`);\n        await writeFilePromise(\n          translationFilePath,\n          JSON.stringify(translation, null, 2)\n        );\n      }\n    }\n  }\n\n  setValueAtPath(obj: any, path: any, value: any) {\n      console.log(`Setting value at path: ${path} to '${value}'`); // Debugging log\n      const keys = path.split(\".\");\n      let current = obj;\n      for (let i = 0; i < keys.length - 1; i++) {\n          const key = keys[i];\n          if (!(key in current) || typeof current[key] !== 'object' || current[key] === null) {\n              current[key] = {};\n          }\n          current = current[key];\n      }\n      current[keys[keys.length - 1]] = value;\n  }\n\n  private async loadJsonFile<T>(filePath: string): Promise<T> {\n    const fileContent = await readFilePromise(filePath, \"utf8\");\n    return JSON.parse(fileContent) as T;\n  }\n\n  private updateWithMissingKeys(\n    baseTranslation: any,\n    targetTranslation: any,\n    path: string[] = []\n): any {\n    const updatedTranslation = JSON.parse(JSON.stringify(targetTranslation)); // Deep copy to avoid mutating the original\n\n    const updateRecursively = (base: any, target: any, currentPath: string[]) => {\n        Object.keys(base).forEach((key) => {\n            const newPath = currentPath.concat(key); // Prepare the new path for potential recursive update\n            if (typeof base[key] === \"object\" && base[key] !== null) {\n                // If the base key is an object, ensure the target has a corresponding object\n                if (!target.hasOwnProperty(key) || typeof target[key] !== \"object\" || target[key] === null) {\n                    console.log(`Creating missing object at path: ${newPath.join(\".\")}`);\n                    target[key] = {}; // Initialize missing object\n                }\n                updateRecursively(base[key], target[key], newPath); // Recurse into objects\n            } else if (!target.hasOwnProperty(key) || target[key] === \"\" || target[key] === null) {\n                // If the key is missing or empty in the target, update it from the base\n                console.log(`Updating missing or empty key at path: ${newPath.join(\".\")}`);\n                target[key] = base[key];\n            }\n            // No action needed for non-empty, non-object fields; they're already present and not empty\n        });\n    };\n\n    updateRecursively(baseTranslation, updatedTranslation, []);\n    return updatedTranslation;\n}\n\n\n  private extractMissingTranslations(\n    baseTranslation: any,\n    targetTranslation: any\n  ): string[] {\n    const missingTranslations: string[] = [];\n\n    const findMissing = (base: any, target: any, path: string[] = []) => {\n      Object.keys(base).forEach((key) => {\n        const newPath = path.concat(key);\n        if (\n          typeof base[key] === \"object\" &&\n          base[key] !== null &&\n          typeof target[key] === \"object\" &&\n          target[key] !== null\n        ) {\n          // Recurse into nested objects\n          findMissing(base[key], target[key], newPath);\n        } else if (\n          !target.hasOwnProperty(key) ||\n          target[key] === base[key] ||\n          target[key] === \"\"\n        ) {\n          // If the key is missing, the value is the same as the base, or the value is an empty string\n          missingTranslations.push(newPath.join(\".\"));\n        }\n      });\n    };\n\n    findMissing(baseTranslation, targetTranslation);\n    return missingTranslations;\n  }\n\n  private chunkArray<T>(array: T[], size: number): T[][] {\n    return array.reduce((acc, val, i) => {\n      let idx = Math.floor(i / size);\n      let page = acc[idx] || (acc[idx] = []);\n      page.push(val);\n      return acc;\n    }, [] as T[][]);\n  }\n\n  renderSystemPrompt() {\n    return `You are a helpful mobile app translation assistant that knows all the world languages.\n\nINPUTS:\nThe user will tell us the Language to translate to.\n\nYou will get JSON with an array of strings to translate:\n[\n  \"string\",\n  ...\n]\n\nOUTPUT:\nYou will output JSON string array in the same order as the input array.\n[\n  \"string\",\n  ...\n]\n\n\nINSTRUCTIONS:\nYou must keep the translated text short, if there is one word in English, it should be one word in the other language. This is UI text for a mobile web app.\nAlways output only JSON.`;\n  }\n\n  renderUserMessage(language: string, textsToTranslate: Array<string>) {\n    return `Language to translate to: ${language}\n\nUI texts to translate in JSON Input:\n${JSON.stringify(textsToTranslate, null, 2)}\n\nYour ${language} UI texts JSON output:`;\n  }\n\n  async translateUITexts(\n    languageIsoCode: string,\n    textsToTranslate: string[]\n  ): Promise<string[] | undefined> {\n    try {\n      console.log(\n        `translateTexts: ${JSON.stringify(textsToTranslate)} ${languageIsoCode}`\n      );\n      const languageName =\n        ISO6391.getName(languageIsoCode) ||\n        ISO6391.getName(languageIsoCode.toLowerCase()) ||\n        ISO6391.getName(languageIsoCode.substring(0, 2)) ||\n        ISO6391.getName(languageIsoCode.substring(0, 2).toLowerCase()) ||\n        \"en\";\n\n      return await this.callLlm(languageName, textsToTranslate);\n    } catch (error) {\n      console.error(\"Error in getAnswerIdeas:\", error);\n      return undefined;\n    }\n  }\n\n  async callLlm(\n    languageName: string,\n    inObject: string[]\n  ): Promise<string[] | undefined> {\n    const messages = [\n      {\n        role: \"system\",\n        content: this.renderSystemPrompt(),\n      },\n      {\n        role: \"user\",\n        content: this.renderUserMessage(languageName, inObject),\n      },\n    ] as any;\n\n    const maxRetries = 3;\n    let retries = 0;\n\n    let running = true;\n\n    while (running) {\n      try {\n        console.log(`Messages ${retries}:`, messages);\n        const results = await this.openaiClient.chat.completions.create({\n          model: this.modelName,\n          messages,\n          max_tokens: this.maxTokens,\n          temperature: this.temperature,\n        });\n\n        console.log(\"Results:\", results);\n        const textJson = results.choices[0].message.content;\n        console.log(\"Text JSON:\", textJson);\n\n        if (textJson) {\n          let cleanText = textJson;\n\n          // Detect and remove markdown code block syntax if present\n          if (cleanText.startsWith(\"```json\") && cleanText.endsWith(\"```\")) {\n            cleanText = cleanText.substring(7, cleanText.length - 3).trim(); // Remove the surrounding markers\n          }\n\n          let translationData: string[] = [];\n          try {\n            translationData = JSON.parse(jsonrepair(cleanText));\n            console.log(\"Parsed Translation Data:\", translationData);\n          } catch (error) {\n            console.error(\"Error parsing cleaned text as JSON:\", error);\n          }\n\n          if (translationData) {\n            running = false;\n            return translationData;\n          }\n        } else {\n          throw new Error(\"No content in response\");\n        }\n      } catch (error) {\n        console.error(\"Error in getChoiceTranslation:\", error);\n        retries++;\n        if (retries > maxRetries) {\n          running = false;\n          return undefined;\n        }\n      }\n    }\n\n    return undefined;\n  }\n}\n\n(async () => {\n  const translator = new YpLocaleTranslation();\n  await translator.loadAndCompareTranslations();\n})();\n"]}