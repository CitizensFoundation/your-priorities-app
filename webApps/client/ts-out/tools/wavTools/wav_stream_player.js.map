{"version":3,"file":"wav_stream_player.js","sourceRoot":"","sources":["../../../src/tools/wavTools/wav_stream_player.ts"],"names":[],"mappings":"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","sourcesContent":["// https://github.com/openai/openai-realtime-console/blob/main/src/lib/wavtools/lib/wav_stream_player.js\n\nimport { StreamProcessorSrc } from './worklets/stream_processor.js';\nimport { AudioAnalysis } from './analysis/audio_analysis.js';\n\ntype AnalysisType = 'frequency' | 'music' | 'voice';\n\ninterface TrackSampleOffset {\n  trackId: string | null;\n  offset: number;\n  currentTime: number;\n}\n\ninterface WavStreamPlayerOptions {\n  sampleRate?: number;\n}\n\ninterface StreamProcessorMessage {\n  event: 'stop' | 'offset' | 'write' | 'interrupt';\n  requestId?: string;\n  trackId?: string;\n  offset?: number;\n  buffer?: Int16Array;\n}\n\n/**\n * Plays audio streams received in raw PCM16 chunks from the browser\n */\nexport class WavStreamPlayer {\n  private readonly scriptSrc: string;\n  private readonly sampleRate: number;\n  private context: AudioContext | null;\n  private stream: AudioWorkletNode | null;\n  private analyser: AnalyserNode | null;\n  private trackSampleOffsets: Record<string, TrackSampleOffset>;\n  private interruptedTrackIds: Record<string, boolean>;\n\n  /**\n   * Creates a new WavStreamPlayer instance\n   * @param options - Configuration options\n   * @returns WavStreamPlayer instance\n   */\n  constructor({ sampleRate = 44100 }: WavStreamPlayerOptions = {}) {\n    this.scriptSrc = StreamProcessorSrc;\n    this.sampleRate = sampleRate;\n    this.context = null;\n    this.stream = null;\n    this.analyser = null;\n    this.trackSampleOffsets = {};\n    this.interruptedTrackIds = {};\n  }\n\n  /**\n   * Connects the audio context and enables output to speakers\n   * @returns Promise resolving to true when connected\n   */\n  async connect(): Promise<true> {\n    this.context = new AudioContext({ sampleRate: this.sampleRate });\n    if (this.context.state === 'suspended') {\n      await this.context.resume();\n    }\n    try {\n      await this.context.audioWorklet.addModule(this.scriptSrc);\n    } catch (e) {\n      console.error(e);\n      throw new Error(`Could not add audioWorklet module: ${this.scriptSrc}`);\n    }\n    const analyser = this.context.createAnalyser();\n    analyser.fftSize = 8192;\n    analyser.smoothingTimeConstant = 0.1;\n    this.analyser = analyser;\n    return true;\n  }\n\n  /**\n   * Gets the current frequency domain data from the playing track\n   * @param analysisType - Type of analysis to perform\n   * @param minDecibels - Minimum decibels level\n   * @param maxDecibels - Maximum decibels level\n   * @returns Audio analysis output\n   */\n  getFrequencies(\n    analysisType: AnalysisType = 'frequency',\n    minDecibels = -100,\n    maxDecibels = -30\n  ): ReturnType<typeof AudioAnalysis.getFrequencies> {\n    if (!this.analyser) {\n      throw new Error('Not connected, please call .connect() first');\n    }\n    return AudioAnalysis.getFrequencies(\n      this.analyser,\n      this.sampleRate,\n      undefined,\n      analysisType,\n      minDecibels,\n      maxDecibels\n    );\n  }\n\n  /**\n   * Starts audio streaming\n   * @private\n   * @returns Promise resolving to true when started\n   */\n  private _start(): Promise<true> {\n    if (!this.context) {\n      throw new Error('AudioContext not initialized');\n    }\n\n    const streamNode = new AudioWorkletNode(this.context, 'stream_processor');\n    streamNode.connect(this.context.destination);\n\n    streamNode.port.onmessage = (e: MessageEvent<StreamProcessorMessage>) => {\n      const { event } = e.data;\n      if (event === 'stop') {\n        streamNode.disconnect();\n        this.stream = null;\n      } else if (event === 'offset') {\n        const { requestId, trackId, offset } = e.data;\n        if (requestId && typeof offset === 'number') {\n          const currentTime = offset / this.sampleRate;\n          this.trackSampleOffsets[requestId] = { trackId: trackId || null, offset, currentTime };\n        }\n      }\n    };\n\n    if (this.analyser) {\n      this.analyser.disconnect();\n      streamNode.connect(this.analyser);\n    }\n\n    this.stream = streamNode;\n    return Promise.resolve(true);\n  }\n\n  /**\n   * Adds 16BitPCM data to the currently playing audio stream\n   * You can add chunks beyond the current play point and they will be queued for play\n   * @param arrayBuffer - Buffer containing PCM data\n   * @param trackId - Identifier for the track\n   * @returns Int16Array containing the PCM data\n   */\n  add16BitPCM(arrayBuffer: ArrayBuffer | Int16Array, trackId = 'default'): Int16Array | void {\n    if (typeof trackId !== 'string') {\n      throw new Error('trackId must be a string');\n    } else if (this.interruptedTrackIds[trackId]) {\n      return;\n    }\n    if (!this.stream) {\n      this._start();\n    }\n\n    let buffer: Int16Array;\n    if (arrayBuffer instanceof Int16Array) {\n      buffer = arrayBuffer;\n    } else if (arrayBuffer instanceof ArrayBuffer) {\n      buffer = new Int16Array(arrayBuffer);\n    } else {\n      throw new Error('argument must be Int16Array or ArrayBuffer');\n    }\n\n    this.stream?.port.postMessage({ event: 'write', buffer, trackId });\n    return buffer;\n  }\n\n  /**\n   * Gets the offset (sample count) of the currently playing stream\n   * @param interrupt - Whether to interrupt the current stream\n   * @returns Track sample offset information\n   */\n  async getTrackSampleOffset(interrupt = false): Promise<TrackSampleOffset | null> {\n    if (!this.stream) {\n      return null;\n    }\n\n    const requestId = crypto.randomUUID();\n    this.stream.port.postMessage({\n      event: interrupt ? 'interrupt' : 'offset',\n      requestId,\n    });\n\n    let trackSampleOffset: TrackSampleOffset | undefined;\n    while (!trackSampleOffset) {\n      trackSampleOffset = this.trackSampleOffsets[requestId];\n      await new Promise((r) => setTimeout(r, 1));\n    }\n\n    const { trackId } = trackSampleOffset;\n    if (interrupt && trackId) {\n      this.interruptedTrackIds[trackId] = true;\n    }\n\n    return trackSampleOffset;\n  }\n\n  /**\n   * Strips the current stream and returns the sample offset of the audio\n   * @param interrupt - Whether to interrupt the current stream\n   * @returns Track sample offset information\n   */\n  async interrupt(): Promise<TrackSampleOffset | null> {\n    return this.getTrackSampleOffset(true);\n  }\n}\n\ndeclare global {\n  var WavStreamPlayer: WavStreamPlayer;\n  interface Window {\n    WavStreamPlayer: WavStreamPlayer;\n  }\n}\n\n(globalThis as any).WavStreamPlayer = WavStreamPlayer;\n"]}