{"version":3,"file":"audio_analysis.js","sourceRoot":"","sources":["../../../../src/tools/wavTools/analysis/audio_analysis.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  noteFrequencies,\n  noteFrequencyLabels,\n  voiceFrequencies,\n  voiceFrequencyLabels,\n} from './constants.js';\n\n/**\n * Output of AudioAnalysis for the frequency domain of the audio\n */\nexport interface AudioAnalysisOutputType {\n  /** Amplitude of this frequency between {0, 1} inclusive */\n  values: Float32Array;\n  /** Raw frequency bucket values */\n  frequencies: number[];\n  /** Labels for the frequency bucket values */\n  labels: string[];\n}\n\n/**\n * Analyzes audio for visual output\n */\nexport class AudioAnalysis {\n  private fftResults: Float32Array[] = [];\n  private audio: HTMLAudioElement;\n  private context: AudioContext | OfflineAudioContext;\n  private analyser: AnalyserNode;\n  private sampleRate: number;\n  private audioBuffer: AudioBuffer | null;\n\n  /**\n   * Retrieves frequency domain data from an AnalyserNode adjusted to a decibel range\n   * returns human-readable formatting and labels\n   * @param analyser\n   * @param sampleRate\n   * @param fftResult\n   * @param analysisType\n   * @param minDecibels default -100\n   * @param maxDecibels default -30\n   * @returns\n   */\n  static getFrequencies(\n    analyser: AnalyserNode,\n    sampleRate: number,\n    fftResult?: Float32Array,\n    analysisType: 'frequency' | 'music' | 'voice' = 'frequency',\n    minDecibels: number = -100,\n    maxDecibels: number = -30,\n  ): AudioAnalysisOutputType {\n    if (!fftResult) {\n      fftResult = new Float32Array(analyser.frequencyBinCount);\n      analyser.getFloatFrequencyData(fftResult);\n    }\n    const nyquistFrequency = sampleRate / 2;\n    const frequencyStep = (1 / fftResult.length) * nyquistFrequency;\n    let outputValues: number[];\n    let frequencies: number[];\n    let labels: string[];\n\n    if (analysisType === 'music' || analysisType === 'voice') {\n      const useFrequencies =\n        analysisType === 'voice' ? voiceFrequencies : noteFrequencies;\n      const aggregateOutput = Array(useFrequencies.length).fill(minDecibels);\n      for (let i = 0; i < fftResult.length; i++) {\n        const frequency = i * frequencyStep;\n        const amplitude = fftResult[i];\n        for (let n = useFrequencies.length - 1; n >= 0; n--) {\n          if (frequency > useFrequencies[n]) {\n            aggregateOutput[n] = Math.max(aggregateOutput[n], amplitude);\n            break;\n          }\n        }\n      }\n      outputValues = aggregateOutput;\n      frequencies = useFrequencies;\n      labels =\n        analysisType === 'voice' ? voiceFrequencyLabels : noteFrequencyLabels;\n    } else {\n      outputValues = Array.from(fftResult);\n      frequencies = outputValues.map((_, i) => frequencyStep * i);\n      labels = frequencies.map((f) => `${f.toFixed(2)} Hz`);\n    }\n\n    // We normalize to {0, 1}\n    const normalizedOutput = outputValues.map((v) => {\n      return Math.max(\n        0,\n        Math.min((v - minDecibels) / (maxDecibels - minDecibels), 1),\n      );\n    });\n    const values = new Float32Array(normalizedOutput);\n    return {\n      values,\n      frequencies,\n      labels,\n    };\n  }\n\n  /**\n   * Creates a new AudioAnalysis instance for an HTMLAudioElement\n   * @param audioElement\n   * @param audioBuffer If provided, will cache all frequency domain data from the buffer\n   */\n  constructor(audioElement: HTMLAudioElement, audioBuffer: AudioBuffer | null = null) {\n    this.audio = audioElement;\n    this.audioBuffer = audioBuffer;\n    this.fftResults = [];\n\n    if (audioBuffer) {\n      /**\n       * Modified from\n       * https://stackoverflow.com/questions/75063715/using-the-web-audio-api-to-analyze-a-song-without-playing\n       *\n       * We do this to populate FFT values for the audio if provided an `audioBuffer`\n       * The reason to do this is that Safari fails when using `createMediaElementSource`\n       * This has a non-zero RAM cost so we only opt-in to run it on Safari, Chrome is better\n       */\n      const { length, sampleRate } = audioBuffer;\n      const offlineAudioContext = new OfflineAudioContext(1, length, sampleRate);\n      const source = offlineAudioContext.createBufferSource();\n      source.buffer = audioBuffer;\n      const analyser = offlineAudioContext.createAnalyser();\n      analyser.fftSize = 8192;\n      analyser.smoothingTimeConstant = 0.1;\n      source.connect(analyser);\n      // limit is :: 128 / sampleRate;\n      // but we just want 60fps - cuts ~1s from 6MB to 1MB of RAM\n      const renderQuantumInSeconds = 1 / 60;\n      const durationInSeconds = length / sampleRate;\n\n      const analyze = (index: number) => {\n        const suspendTime = renderQuantumInSeconds * index;\n        if (suspendTime < durationInSeconds) {\n          offlineAudioContext.suspend(suspendTime).then(() => {\n            const fftResult = new Float32Array(analyser.frequencyBinCount);\n            analyser.getFloatFrequencyData(fftResult);\n            this.fftResults.push(fftResult);\n            analyze(index + 1);\n          });\n        }\n        if (index === 1) {\n          offlineAudioContext.startRendering();\n        } else {\n          offlineAudioContext.resume();\n        }\n      };\n      source.start(0);\n      analyze(1);\n      this.context = offlineAudioContext;\n      this.analyser = analyser;\n      this.sampleRate = sampleRate;\n    } else {\n      const audioContext = new AudioContext();\n      const track = audioContext.createMediaElementSource(audioElement);\n      const analyser = audioContext.createAnalyser();\n      analyser.fftSize = 8192;\n      analyser.smoothingTimeConstant = 0.1;\n      track.connect(analyser);\n      analyser.connect(audioContext.destination);\n      this.context = audioContext;\n      this.analyser = analyser;\n      this.sampleRate = this.context.sampleRate;\n    }\n  }\n\n  /**\n   * Gets the current frequency domain data from the playing audio track\n   * @param analysisType\n   * @param minDecibels default -100\n   * @param maxDecibels default -30\n   * @returns\n   */\n  getFrequencies(\n    analysisType: 'frequency' | 'music' | 'voice' = 'frequency',\n    minDecibels: number = -100,\n    maxDecibels: number = -30,\n  ): AudioAnalysisOutputType {\n    let fftResult: Float32Array | null = null;\n    if (this.audioBuffer && this.fftResults.length) {\n      const pct = this.audio.currentTime / this.audio.duration;\n      const index = Math.min(\n        Math.floor(pct * this.fftResults.length),\n        this.fftResults.length - 1,\n      );\n      fftResult = this.fftResults[index];\n    }\n    return AudioAnalysis.getFrequencies(\n      this.analyser,\n      this.sampleRate,\n      fftResult || undefined,\n      analysisType,\n      minDecibels,\n      maxDecibels,\n    );\n  }\n\n  /**\n   * Resume the internal AudioContext if it was suspended due to the lack of\n   * user interaction when the AudioAnalysis was instantiated.\n   * @returns\n   */\n  async resumeIfSuspended(): Promise<true> {\n    if (this.context.state === 'suspended') {\n      await this.context.resume();\n    }\n    return true;\n  }\n}\n\n(globalThis as any).AudioAnalysis = AudioAnalysis;\n"]}