{"version":3,"file":"wav_recorder.js","sourceRoot":"","sources":["../../../src/tools/wavTools/wav_recorder.ts"],"names":[],"mappings":"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","sourcesContent":["// From https://github.com/openai/openai-realtime-console/blob/main/src/lib/wavtools/lib/wav_recorder.js\n\nimport { AudioProcessorSrc } from './worklets/audio_processor.js';\nimport { AudioAnalysis, AudioAnalysisOutputType } from './analysis/audio_analysis.js';\nimport { WavPacker, WavPackerAudioType } from './wav_packer.js';\n\n/**\n * Decodes audio into a wav file\n */\ninterface DecodedAudioType {\n  blob: Blob;\n  url: string;\n  values: Float32Array;\n  audioBuffer: AudioBuffer;\n}\n\n/**\n * Records live stream of user audio as PCM16 \"audio/wav\" data\n */\nexport class WavRecorder {\n  private scriptSrc: string;\n  private sampleRate: number;\n  private outputToSpeakers: boolean;\n  private debug: boolean;\n  private _deviceChangeCallback: ((devices: (MediaDeviceInfo & { default: boolean })[]) => void) | null;\n  private _devices: MediaDeviceInfo[];\n  private stream: MediaStream | null;\n  private processor: AudioWorkletNode | null;\n  private source: MediaStreamAudioSourceNode | null;\n  private node: AudioNode | null;\n  private recording: boolean;\n  private _lastEventId: number;\n  private eventReceipts: { [key: number]: any };\n  private eventTimeout: number;\n  private _chunkProcessor: (data: { mono: Int16Array; raw: Int16Array }) => any;\n  private _chunkProcessorSize: number | undefined;\n  private _chunkProcessorBuffer: {\n    raw: ArrayBuffer;\n    mono: ArrayBuffer;\n  };\n  private analyser: AnalyserNode | null;\n\n  /**\n   * Create a new WavRecorder instance\n   */\n  constructor({\n    sampleRate = 44100,\n    outputToSpeakers = false,\n    debug = false,\n  }: {\n    sampleRate?: number;\n    outputToSpeakers?: boolean;\n    debug?: boolean;\n  } = {}) {\n    // Script source\n    this.scriptSrc = AudioProcessorSrc;\n    // Config\n    this.sampleRate = sampleRate;\n    this.outputToSpeakers = outputToSpeakers;\n    this.debug = !!debug;\n    this._deviceChangeCallback = null;\n    this._devices = [];\n    // State variables\n    this.stream = null;\n    this.processor = null;\n    this.source = null;\n    this.node = null;\n    this.recording = false;\n    // Event handling with AudioWorklet\n    this._lastEventId = 0;\n    this.eventReceipts = {};\n    this.eventTimeout = 5000;\n    // Process chunks of audio\n    this._chunkProcessor = () => {};\n    this._chunkProcessorSize = undefined;\n    this._chunkProcessorBuffer = {\n      raw: new ArrayBuffer(0),\n      mono: new ArrayBuffer(0),\n    };\n    this.analyser = null;\n  }\n\n  /**\n   * Decodes audio data from multiple formats to a Blob, url, Float32Array and AudioBuffer\n   */\n  static async decode(\n    audioData: Blob | Float32Array | Int16Array | ArrayBuffer | number[],\n    sampleRate = 44100,\n    fromSampleRate = -1,\n  ): Promise<DecodedAudioType> {\n    const context = new AudioContext({ sampleRate });\n    let arrayBuffer: ArrayBuffer;\n    let blob: Blob;\n    if (audioData instanceof Blob) {\n      if (fromSampleRate !== -1) {\n        throw new Error(\n          `Can not specify \"fromSampleRate\" when reading from Blob`,\n        );\n      }\n      blob = audioData;\n      arrayBuffer = await blob.arrayBuffer();\n    } else if (audioData instanceof ArrayBuffer) {\n      if (fromSampleRate !== -1) {\n        throw new Error(\n          `Can not specify \"fromSampleRate\" when reading from ArrayBuffer`,\n        );\n      }\n      arrayBuffer = audioData;\n      blob = new Blob([arrayBuffer], { type: 'audio/wav' });\n    } else {\n      let float32Array: Float32Array;\n      let data: Int16Array | undefined;\n      if (audioData instanceof Int16Array) {\n        data = audioData;\n        float32Array = new Float32Array(audioData.length);\n        for (let i = 0; i < audioData.length; i++) {\n          float32Array[i] = audioData[i] / 0x8000;\n        }\n      } else if (audioData instanceof Float32Array) {\n        float32Array = audioData;\n      } else if (Array.isArray(audioData)) {\n        float32Array = new Float32Array(audioData);\n      } else {\n        throw new Error(\n          `\"audioData\" must be one of: Blob, Float32Array, Int16Array, ArrayBuffer, Array<number>`,\n        );\n      }\n      if (fromSampleRate === -1) {\n        throw new Error(\n          `Must specify \"fromSampleRate\" when reading from Float32Array, In16Array or Array`,\n        );\n      } else if (fromSampleRate < 3000) {\n        throw new Error(`Minimum \"fromSampleRate\" is 3000 (3kHz)`);\n      }\n      if (!data) {\n        data = WavPacker.floatTo16BitPCM(float32Array) as Int16Array;\n      }\n      const audio = {\n        bitsPerSample: 16,\n        channels: [float32Array],\n        data: data,\n      };\n      const packer = new WavPacker();\n      const result = packer.pack(fromSampleRate, audio);\n      blob = result.blob;\n      arrayBuffer = await blob.arrayBuffer();\n    }\n    const audioBuffer = await context.decodeAudioData(arrayBuffer);\n    const values = audioBuffer.getChannelData(0);\n    const url = URL.createObjectURL(blob);\n    return {\n      blob,\n      url,\n      values,\n      audioBuffer,\n    };\n  }\n\n  /**\n   * Logs data in debug mode\n   */\n  log(...args: any[]): true {\n    if (this.debug) {\n      console.log(...args);\n    }\n    return true;\n  }\n\n  /**\n   * Retrieves the current sampleRate for the recorder\n   */\n  getSampleRate(): number {\n    return this.sampleRate;\n  }\n\n  /**\n   * Retrieves the current status of the recording\n   */\n  getStatus(): 'ended' | 'paused' | 'recording' {\n    if (!this.processor) {\n      return 'ended';\n    } else if (!this.recording) {\n      return 'paused';\n    } else {\n      return 'recording';\n    }\n  }\n\n  /**\n   * Sends an event to the AudioWorklet\n   */\n  private async _event(\n    name: string,\n    data: { [key: string]: any } = {},\n    _processor: AudioWorkletNode | null = null,\n  ): Promise<{ [key: string]: any }> {\n    _processor = _processor || this.processor;\n    if (!_processor) {\n      throw new Error('Can not send events without recording first');\n    }\n    const message = {\n      event: name,\n      id: this._lastEventId++,\n      data,\n    };\n    _processor.port.postMessage(message);\n    const t0 = new Date().valueOf();\n    while (!this.eventReceipts[message.id]) {\n      if (new Date().valueOf() - t0 > this.eventTimeout) {\n        throw new Error(`Timeout waiting for \"${name}\" event`);\n      }\n      await new Promise((res) => setTimeout(() => res(true), 1));\n    }\n    const payload = this.eventReceipts[message.id];\n    delete this.eventReceipts[message.id];\n    return payload;\n  }\n\n  /**\n   * Sets device change callback, remove if callback provided is `null`\n   */\n  listenForDeviceChange(\n    callback: ((devices: (MediaDeviceInfo & { default: boolean })[]) => void) | null,\n  ): true {\n    if (callback === null && this._deviceChangeCallback) {\n      navigator.mediaDevices.removeEventListener(\n        'devicechange',\n        this._deviceChangeCallback as any,\n      );\n      this._deviceChangeCallback = null;\n    } else if (callback !== null) {\n      let lastId = 0;\n      let lastDevices: (MediaDeviceInfo & { default: boolean })[] = [];\n      const serializeDevices = (devices: MediaDeviceInfo[]) =>\n        devices\n          .map((d) => d.deviceId)\n          .sort()\n          .join(',');\n      const cb = async () => {\n        let id = ++lastId;\n        const devices = await this.listDevices();\n        if (id === lastId) {\n          if (serializeDevices(lastDevices) !== serializeDevices(devices)) {\n            lastDevices = devices as any;\n            callback(devices.slice() as any);\n          }\n        }\n      };\n      navigator.mediaDevices.addEventListener('devicechange', cb);\n      cb();\n      this._deviceChangeCallback = cb;\n    }\n    return true;\n  }\n\n  /**\n   * Manually request permission to use the microphone\n   */\n  async requestPermission(): Promise<true> {\n    const permissionStatus = await navigator.permissions.query({\n      name: 'microphone' as PermissionName,\n    });\n    if (permissionStatus.state === 'denied') {\n      window.alert('You must grant microphone access to use this feature.');\n    } else if (permissionStatus.state === 'prompt') {\n      try {\n        const stream = await navigator.mediaDevices.getUserMedia({\n          audio: true,\n        });\n        const tracks = stream.getTracks();\n        tracks.forEach((track) => track.stop());\n      } catch (e) {\n        window.alert('You must grant microphone access to use this feature.');\n      }\n    }\n    return true;\n  }\n\n  /**\n   * List all eligible devices for recording, will request permission to use microphone\n   */\n  async listDevices(): Promise<(MediaDeviceInfo & { default?: boolean })[]> {\n    if (\n      !navigator.mediaDevices ||\n      !('enumerateDevices' in navigator.mediaDevices)\n    ) {\n      throw new Error('Could not request user devices');\n    }\n    await this.requestPermission();\n    const devices = await navigator.mediaDevices.enumerateDevices();\n    const audioDevices = devices.filter(\n      (device) => device.kind === 'audioinput',\n    );\n    const defaultDeviceIndex = audioDevices.findIndex(\n      (device) => device.deviceId === 'default',\n    );\n    const deviceList: (MediaDeviceInfo & { default?: boolean })[] = [];\n    if (defaultDeviceIndex !== -1) {\n      let defaultDevice = audioDevices.splice(defaultDeviceIndex, 1)[0];\n      let existingIndex = audioDevices.findIndex(\n        (device) => device.groupId === defaultDevice.groupId,\n      );\n      if (existingIndex !== -1) {\n        defaultDevice = audioDevices.splice(existingIndex, 1)[0];\n      }\n      defaultDevice = { ...defaultDevice, default: true } as any;\n      deviceList.push(defaultDevice);\n    }\n    return deviceList.concat(audioDevices);\n  }\n\n  /**\n   * Begins a recording session and requests microphone permissions if not already granted\n   * Microphone recording indicator will appear on browser tab but status will be \"paused\"\n   */\n  async begin(deviceId?: string): Promise<true> {\n    if (this.processor) {\n      throw new Error(\n        `Already connected: please call .end() to start a new session`,\n      );\n    }\n\n    if (\n      !navigator.mediaDevices ||\n      !('getUserMedia' in navigator.mediaDevices)\n    ) {\n      throw new Error('Could not request user media');\n    }\n    try {\n      const config: MediaStreamConstraints = { audio: true };\n      if (deviceId) {\n        config.audio = { deviceId: { exact: deviceId } };\n      }\n      this.stream = await navigator.mediaDevices.getUserMedia(config);\n    } catch (err) {\n      console.error('Could not start media stream');\n      document.dispatchEvent(new CustomEvent(\"yp-error\", { detail: \"Can't find microphone\" }) );\n      throw new Error('Could not start media stream');\n    }\n\n    const context = new AudioContext({ sampleRate: this.sampleRate });\n    const source = context.createMediaStreamSource(this.stream);\n    // Load and execute the module script.\n    try {\n      await context.audioWorklet.addModule(this.scriptSrc);\n    } catch (e) {\n      console.error(e);\n      throw new Error(`Could not add audioWorklet module: ${this.scriptSrc}`);\n    }\n    const processor = new AudioWorkletNode(context, 'audio_processor');\n    processor.port.onmessage = (e: MessageEvent) => {\n      const { event, id, data } = e.data;\n      if (event === 'receipt') {\n        this.eventReceipts[id] = data;\n      } else if (event === 'chunk') {\n        if (this._chunkProcessorSize) {\n          const buffer = this._chunkProcessorBuffer;\n          this._chunkProcessorBuffer = {\n            raw: WavPacker.mergeBuffers(buffer.raw, data.raw),\n            mono: WavPacker.mergeBuffers(buffer.mono, data.mono),\n          };\n          if (\n            this._chunkProcessorBuffer.mono.byteLength >=\n            this._chunkProcessorSize\n          ) {\n            this._chunkProcessor(this._chunkProcessorBuffer as any);\n            this._chunkProcessorBuffer = {\n              raw: new ArrayBuffer(0),\n              mono: new ArrayBuffer(0),\n            };\n          }\n        } else {\n          this._chunkProcessor(data);\n        }\n      }\n    };\n\n    const node = source.connect(processor);\n    const analyser = context.createAnalyser();\n    analyser.fftSize = 8192;\n    analyser.smoothingTimeConstant = 0.1;\n    node.connect(analyser);\n    if (this.outputToSpeakers) {\n      // eslint-disable-next-line no-console\n      console.warn(\n        'Warning: Output to speakers may affect sound quality,\\n' +\n          'especially due to system audio feedback preventative measures.\\n' +\n          'use only for debugging',\n      );\n      analyser.connect(context.destination);\n    }\n\n    this.source = source;\n    this.node = node;\n    this.analyser = analyser;\n    this.processor = processor;\n    return true;\n  }\n\n  /**\n   * Gets the current frequency domain data from the recording track\n   */\n  getFrequencies(\n    analysisType: 'frequency' | 'music' | 'voice' = 'frequency',\n    minDecibels = -100,\n    maxDecibels = -30,\n  ): AudioAnalysisOutputType {\n    if (!this.processor) {\n      throw new Error('Session ended: please call .begin() first');\n    }\n    return AudioAnalysis.getFrequencies(\n      this.analyser!,\n      this.sampleRate,\n      undefined,\n      analysisType,\n      minDecibels,\n      maxDecibels,\n    );\n  }\n\n  /**\n   * Pauses the recording\n   * Keeps microphone stream open but halts storage of audio\n   */\n  async pause(): Promise<true> {\n    if (!this.processor) {\n      throw new Error('Session ended: please call .begin() first');\n    } else if (!this.recording) {\n      throw new Error('Already paused: please call .record() first');\n    }\n    if (this._chunkProcessorBuffer.raw.byteLength) {\n      this._chunkProcessor(this._chunkProcessorBuffer as any);\n    }\n    this.log('Pausing ...');\n    await this._event('stop');\n    this.recording = false;\n    return true;\n  }\n\n  /**\n   * Start recording stream and storing to memory from the connected audio source\n   */\n  async record(\n    chunkProcessor: (data: { mono: Int16Array; raw: Int16Array }) => any = () => {},\n    chunkSize: number = 8192,\n  ): Promise<true> {\n    if (!this.processor) {\n      throw new Error('Session ended: please call .begin() first');\n    } else if (this.recording) {\n      throw new Error('Already recording: please call .pause() first');\n    } else if (typeof chunkProcessor !== 'function') {\n      throw new Error(`chunkProcessor must be a function`);\n    }\n    this._chunkProcessor = chunkProcessor;\n    this._chunkProcessorSize = chunkSize;\n    this._chunkProcessorBuffer = {\n      raw: new ArrayBuffer(0),\n      mono: new ArrayBuffer(0),\n    };\n    this.log('Recording ...');\n    await this._event('start');\n    this.recording = true;\n    return true;\n  }\n\n  /**\n   * Clears the audio buffer, empties stored recording\n   */\n  async clear(): Promise<true> {\n    if (!this.processor) {\n      throw new Error('Session ended: please call .begin() first');\n    }\n    await this._event('clear');\n    return true;\n  }\n\n  /**\n   * Reads the current audio stream data\n   */\n  async read(): Promise<{\n    meanValues: Float32Array;\n    channels: Float32Array[];\n  }> {\n    if (!this.processor) {\n      throw new Error('Session ended: please call .begin() first');\n    }\n    this.log('Reading ...');\n    const result = await this._event('read');\n    return result as any;\n  }\n\n  /**\n   * Saves the current audio stream to a file\n   */\n  async save(force = false): Promise<WavPackerAudioType> {\n    if (!this.processor) {\n      throw new Error('Session ended: please call .begin() first');\n    }\n    if (!force && this.recording) {\n      throw new Error(\n        'Currently recording: please call .pause() first, or call .save(true) to force',\n      );\n    }\n    this.log('Exporting ...');\n    const exportData = await this._event('export');\n    const packer = new WavPacker();\n    const result = packer.pack(this.sampleRate, exportData.audio);\n    return result;\n  }\n\n  /**\n   * Ends the current recording session and saves the result\n   */\n  async end(): Promise<WavPackerAudioType> {\n    if (!this.processor) {\n      throw new Error('Session ended: please call .begin() first');\n    }\n\n    const _processor = this.processor;\n\n    this.log('Stopping ...');\n    await this._event('stop');\n    this.recording = false;\n    const tracks = this.stream!.getTracks();\n    tracks.forEach((track) => track.stop());\n\n    this.log('Exporting ...');\n    const exportData = await this._event('export', {}, _processor);\n\n    this.processor.disconnect();\n    this.source!.disconnect();\n    this.node!.disconnect();\n    this.analyser!.disconnect();\n    this.stream = null;\n    this.processor = null;\n    this.source = null;\n    this.node = null;\n\n    const packer = new WavPacker();\n    const result = packer.pack(this.sampleRate, exportData.audio);\n    return result;\n  }\n\n  /**\n   * Performs a full cleanup of WavRecorder instance\n   * Stops actively listening via microphone and removes existing listeners\n   */\n  async quit(): Promise<true> {\n    this.listenForDeviceChange(null);\n    if (this.processor) {\n      await this.end();\n    }\n    return true;\n  }\n}\n\n(globalThis as any)['WavRecorder'] = WavRecorder;\n"]}