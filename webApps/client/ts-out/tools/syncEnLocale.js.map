{"version":3,"file":"syncEnLocale.js","sourceRoot":"","sources":["../../src/tools/syncEnLocale.ts"],"names":[],"mappings":"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","sourcesContent":["import * as fs from \"fs\";\nimport * as path from \"path\";\nimport * as glob from \"glob\";\n\n//TODO: Save a copy of the translation file before updating it, then use that copy to compare and to delete the keys that have changed in the en\n\n// Define paths\nconst srcDirectory = \"./src/\";\nconst translationFilePath = \"./locales/en/translation.json\";\nconst outputFilePath = \"/tmp/translation.json\";\n\n// Function to recursively find .js and .ts files\n// Function to recursively find .js and .ts files, excluding paths with 'test'\nfunction findFiles(directory: string, extensionRegex: RegExp, foundFiles: string[] = []): Promise<string[]> {\n  return new Promise((resolve, reject) => {\n      fs.readdir(directory, { withFileTypes: true }, (err, files) => {\n          if (err) {\n              return reject(err);\n          }\n\n          // Process each file or directory\n          const promises = files.map(file => {\n              const filePath = path.join(directory, file.name);\n              if (file.isDirectory()) {\n                  // Recurse into subdirectories, unless the directory name includes 'test'\n                  if (!filePath.toLowerCase().includes('test')) {\n                      return findFiles(filePath, extensionRegex, foundFiles);\n                  }\n              } else if (extensionRegex.test(file.name) && !filePath.toLowerCase().includes('test')) {\n                  // Add file if it matches .js or .ts and does not include 'test'\n                  foundFiles.push(filePath);\n              }\n              return Promise.resolve();\n          });\n\n          // Wait for all files and subdirectories to be processed\n          Promise.all(promises).then(() => resolve(foundFiles)).catch(reject);\n      });\n  });\n}\n\n\n// Function to read file content\nasync function readFileContent(filePath: string): Promise<string> {\n  return fs.promises.readFile(filePath, \"utf8\");\n}\n\n// Function to extract translation keys using regex\nfunction extractTranslationKeys(fileContent: string): string[] {\n  const keys = [];\n  // Updated regex to match all specified patterns, including the new name pattern\n  const regex =\n    /this\\.t\\(['\"`](.*?)['\"`]\\)|\\[\\[t\\(['\"`](.*?)['\"`]\\)\\]\\]|\\{\\{t\\(['\"`](.*?)['\"`]\\)\\}\\}|translationToken:\\s*['\"`](.*?)['\"`]|text:\\s*['\"`](.*?)['\"`],|name:\\s*['\"`](.*?)['\"`]/g;\n  let match;\n\n  while ((match = regex.exec(fileContent)) !== null) {\n    // Since there are multiple capturing groups for different patterns,\n    // find the first non-undefined group to determine the matched key.\n    const key = match.slice(1).find((m) => m !== undefined);\n    if (key) {\n      keys.push(key);\n    }\n  }\n\n  return keys;\n}\n\n// Function to read and parse the translation file\nasync function readTranslationFile(filePath: string): Promise<any> {\n  const content = await fs.promises.readFile(filePath, \"utf8\");\n  return JSON.parse(content);\n}\n\n// Function to save the updated translation file\nasync function saveUpdatedTranslationFile(\n  filePath: string,\n  content: any\n): Promise<void> {\n  await fs.promises.writeFile(filePath, JSON.stringify(content, null, 2));\n}\n\n// Function to deeply check and remove unused keys, and count changes\n// Function to deeply check and remove unused keys, and count changes\nfunction updateTranslations(\n  usedKeys: string[],\n  translations: any\n): { updatedTranslations: any; deletedCount: number; newCount: number } {\n  let deletedCount = 0;\n  let newCount = 0;\n\n  function traverseTranslations(\n    keys: Set<string>,\n    current: any,\n    path: string\n  ): any {\n    return Object.fromEntries(\n      Object.entries(current).flatMap(([key, value]) => {\n        const fullPath = path ? `${path}.${key}` : key;\n        if (\n          typeof value === \"object\" &&\n          value !== null &&\n          !Array.isArray(value)\n        ) {\n          return [[key, traverseTranslations(keys, value, fullPath)]];\n        } else {\n          if (keys.has(fullPath)) {\n            return [[key, value]];\n          } else {\n            deletedCount++;\n            return [];\n          }\n        }\n      })\n    );\n  }\n\n  function findNewKeys(keys: Set<string>, current: any, path: string) {\n    keys.forEach((key) => {\n      const keyPath = key.split('.');\n      let tempCurrent = current;\n      for (let i = 0; i < keyPath.length; i++) {\n        const part = keyPath[i];\n\n        // Ensure the current part of the path exists before trying to access it\n        if (typeof tempCurrent !== 'object' || tempCurrent === null) {\n          console.warn(`Warning: Trying to access or create a property on a non-object or null at path: '${keyPath.slice(0, i).join('.')}'.`);\n          // Initialize the current path as an object to continue traversal\n          tempCurrent = {};\n        }\n\n        if (i === keyPath.length - 1) {\n          // We're at the end of the path, so add the key if it doesn't exist\n          if (tempCurrent[part] === undefined) {\n            tempCurrent[part] = `${key}`;\n            newCount++;\n          }\n        } else {\n          // Not at the end, so ensure there's an object to traverse into\n          if (tempCurrent[part] === undefined) {\n            tempCurrent[part] = {};\n          } else if (typeof tempCurrent[part] === 'string') {\n            // We've encountered a string where we expected an object, so report the conflict\n            console.warn(`Warning: The key '${keyPath.slice(0, i + 1).join('.')}' is expected to be an object, but it is a string.`);\n            // Rename the key and initialize as an object to resolve the conflict\n            const newKey = `${part}Tree`;\n            if (tempCurrent[newKey] === undefined) {\n              tempCurrent[newKey] = {};\n            }\n            tempCurrent[newKey][keyPath[i + 1]] = tempCurrent[part];\n            delete tempCurrent[part];\n            tempCurrent = tempCurrent[newKey];\n            continue;\n          }\n        }\n        // Proceed to the next part of the path\n        tempCurrent = tempCurrent[part];\n      }\n    });\n  }\n\n\n  const updatedTranslations = traverseTranslations(\n    new Set(usedKeys),\n    translations,\n    \"\"\n  );\n  findNewKeys(new Set(usedKeys), updatedTranslations, \"\");\n\n  return { updatedTranslations, deletedCount, newCount };\n}\n\n// Main function to process translations\nasync function processTranslations() {\n  try {\n    const srcDirectory = \"./src\";\n    const extensionsRegex = /\\.(js|ts)$/;\n    let files = await findFiles(srcDirectory, extensionsRegex);\n    console.log(`Found ${files.length} files.`);\n    let moreFile = await findFiles(\"../old/clientApp/src/\", /\\.(html)$/);\n    console.log(`Found more ${moreFile.length} files.`);\n    files = files.concat(moreFile);\n    const translationKeys = new Set<string>();\n    const translations = await readTranslationFile(translationFilePath);\n\n    for (const file of files) {\n      const content = await readFileContent(file);\n      const keys = extractTranslationKeys(content);\n      keys.forEach((key) => translationKeys.add(key));\n    }\n\n    const { updatedTranslations, deletedCount, newCount } = updateTranslations(\n      Array.from(translationKeys),\n      translations\n    );\n\n    await saveUpdatedTranslationFile(outputFilePath, updatedTranslations);\n    console.log(\n      `Translation file has been updated. New tokens: ${newCount}, Deleted tokens: ${deletedCount}`\n    );\n  } catch (error) {\n    console.error(\"Error processing translations:\", error);\n  }\n}\n\n// Execute the main function\nprocessTranslations();\n"]}