{"version":3,"file":"AudioBackup.js","sourceRoot":"","sources":["../../../src/yp-avatars/hey-gen/AudioBackup.ts"],"names":[],"mappings":"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","sourcesContent":["// audioBackup.ts\nexport interface AudioBackupConfig {\n  sessionId: string;\n  sendInterval: number;\n  backupEndpoint: string;\n  headers?: Record<string, string>;\n}\n\nexport class AudioBackupManager {\n  private audioBuffer: Float32Array[] = [];\n  private mediaRecorder: MediaRecorder | null = null;\n  private audioContext: AudioContext | null = null;\n  private sourceNode: MediaStreamAudioSourceNode | null = null;\n  private processorNode: ScriptProcessorNode | null = null;\n  private sendIntervalId: number | null = null;\n  private isRecording = false;\n\n  constructor(private config: AudioBackupConfig) {}\n\n  public attachToStream(stream: MediaStream): void {\n    if (this.isRecording) return;\n\n    try {\n      // Create audio context and nodes\n      this.audioContext = new AudioContext({\n        sampleRate: 16000,\n        latencyHint: 'interactive'\n      });\n\n      // Create a duplicate stream for backup\n      this.sourceNode = this.audioContext.createMediaStreamSource(stream);\n      this.processorNode = this.audioContext.createScriptProcessor(512, 1, 1);\n\n      // Set up audio processing\n      this.processorNode.onaudioprocess = (event) => {\n        if (!this.isRecording) return;\n        const audioData = event.inputBuffer.getChannelData(0);\n        this.audioBuffer.push(new Float32Array(audioData));\n      };\n\n      // Connect nodes\n      this.sourceNode.connect(this.processorNode);\n      this.processorNode.connect(this.audioContext.destination);\n\n      // Start periodic sending\n      this.isRecording = true;\n      this.sendIntervalId = window.setInterval(() => {\n        this.sendAudioChunks();\n      }, this.config.sendInterval);\n\n    } catch (error) {\n      console.error('Error setting up audio backup:', error);\n    }\n  }\n\n  public stop(): void {\n    this.isRecording = false;\n\n    if (this.sendIntervalId) {\n      window.clearInterval(this.sendIntervalId);\n      this.sendIntervalId = null;\n    }\n\n    // Clean up audio nodes\n    if (this.processorNode) {\n      this.processorNode.disconnect();\n      this.processorNode = null;\n    }\n\n    if (this.sourceNode) {\n      this.sourceNode.disconnect();\n      this.sourceNode = null;\n    }\n\n    if (this.audioContext) {\n      this.audioContext.close();\n      this.audioContext = null;\n    }\n\n    // Send any remaining audio\n    this.sendAudioChunks();\n    this.audioBuffer = [];\n  }\n\n  private async sendAudioChunks(): Promise<void> {\n    if (this.audioBuffer.length === 0) return;\n\n    try {\n      // Combine all chunks\n      const totalLength = this.audioBuffer.reduce((acc, chunk) => acc + chunk.length, 0);\n      const combinedAudio = new Float32Array(totalLength);\n\n      let offset = 0;\n      for (const chunk of this.audioBuffer) {\n        combinedAudio.set(chunk, offset);\n        offset += chunk.length;\n      }\n\n      // Prepare payload\n      const audioArray = Array.from(combinedAudio);\n      const payload = {\n        timestamp: Date.now(),\n        audioData: btoa(String.fromCharCode.apply(null, audioArray)),\n        sampleRate: 16000,\n        channels: 1,\n        sessionId: this.config.sessionId\n      };\n\n      // Send to backup endpoint\n      await fetch(this.config.backupEndpoint, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          ...this.config.headers\n        },\n        body: JSON.stringify(payload)\n      });\n\n      // Clear buffer after successful send\n      this.audioBuffer = [];\n    } catch (error) {\n      console.error('Error sending audio backup:', error);\n      // Keep buffer in case of error\n    }\n  }\n}"]}