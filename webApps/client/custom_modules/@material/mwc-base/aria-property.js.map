{"version":3,"file":"aria-property.js","sourceRoot":"","sources":["aria-property.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAkBH;;;GAGG;AACH,SAAS,WAAW,CAChB,SAAa,EAAE,IAAY,EAAE,UAA+B;IAC9D,MAAM,WAAW,GACZ,SAAS,CAAC,WAAmD,CAAC;IACnE,IAAI,CAAC,UAAU,EAAE;QACf;;;WAGG;QACH,MAAM,sBAAsB,GAAG,KAAK,IAAI,EAAE,CAAC;QAC3C,UAAU;YACN,WAAW,CAAC,qBAAqB,CAAC,IAAI,EAAE,sBAAsB,CAAC,CAAC;QACpE,IAAI,CAAC,UAAU,EAAE;YACf,MAAM,IAAI,KAAK,CAAC,wDAAwD,CAAC,CAAC;SAC3E;KACF;IAED,0EAA0E;IAC1E,MAAM,cAAc,GAAG,UAAU,CAAC;IAClC,IAAI,SAAS,GAAG,EAAE,CAAC;IAEnB,IAAI,CAAC,cAAc,CAAC,GAAG,EAAE;QACvB,MAAM,IAAI,KAAK,CAAC,uCAAuC,IAAI,EAAE,CAAC,CAAC;KAChE;IAGD,gEAAgE;IAChE,aAAa;IACb,8EAA8E;IAC9E,IAAK,SAAiB,CAAC,gBAAgB,EAAE;QACvC,OAAO,UAAU,CAAC;KACnB;IAED,MAAM,iBAAiB,GAAuB;QAC5C,YAAY,EAAE,IAAI;QAClB,UAAU,EAAE,IAAI;QAChB,GAAG,CAAwB,KAAc;YACvC,IAAI,SAAS,KAAK,EAAE,EAAE;gBACpB,MAAM,OAAO,GAAG,WAAW,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC;gBACrD,mDAAmD;gBACnD,SAAS;oBACL,OAAO,OAAO,CAAC,SAAS,KAAK,QAAQ,CAAC,CAAC,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC;aACtE;YACD,IAAI,IAAI,CAAC,YAAY,CAAC,SAAS,CAAC,EAAE;gBAChC,IAAI,CAAC,eAAe,CAAC,SAAS,CAAC,CAAC;aACjC;YACD,cAAc,CAAC,GAAI,CAAC,IAAI,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;QACxC,CAAC;KACF,CAAC;IAEF,IAAI,cAAc,CAAC,GAAG,EAAE;QACtB,iBAAiB,CAAC,GAAG,GAAG;YACtB,OAAO,cAAc,CAAC,GAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACxC,CAAC,CAAC;KACH;IAED,OAAO,iBAAiB,CAAC;AAC3B,CAAC;AAED;;;;;;;;;;;;;;;;;;;;;;;GAuBG;AACH,MAAM,UAAU,YAAY,CACxB,iBAAqB,EAAE,IAAa;AACpC,mFAAmF;AACnF,UAA+B;IACjC,IAAI,IAAI,KAAK,SAAS,EAAE;QACtB,OAAO,WAAW,CAAC,iBAAiB,EAAE,IAAI,EAAE,UAAU,CAAC,CAAC;KACzD;SAAM;QACL,MAAM,IAAI,KAAK,CAAC,mDAAmD,CAAC,CAAC;KACtE;AACH,CAAC","sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {PropertyDeclaration, ReactiveElement} from '@lit/reactive-element';\n\n/**\n * A value for the `aria-haspopup` ARIA attribute.\n */\nexport type AriaHasPopup =\n    'false'|'true'|'menu'|'listbox'|'tree'|'grid'|'dialog';\n\n/**\n * Expose protected statics on ReactiveElement\n */\ninterface ReactiveElementInternals {\n  getPropertyDescriptor(name: PropertyKey, key: string): PropertyDescriptor;\n  getPropertyOptions(name: PropertyKey): PropertyDeclaration;\n}\n\n/**\n * TypeScript version of the decorator\n * @see https://www.typescriptlang.org/docs/handbook/decorators.html#property-decorators\n */\nfunction tsDecorator(\n    prototype: {}, name: string, descriptor?: PropertyDescriptor) {\n  const constructor =\n      (prototype.constructor as unknown as ReactiveElementInternals);\n  if (!descriptor) {\n    /**\n     * lit uses internal properties with two leading underscores to\n     * provide storage for accessors\n     */\n    const litInternalPropertyKey = `__${name}`;\n    descriptor =\n        constructor.getPropertyDescriptor(name, litInternalPropertyKey);\n    if (!descriptor) {\n      throw new Error('@ariaProperty must be used after a @property decorator');\n    }\n  }\n\n  // descriptor must exist at this point, reassign so typescript understands\n  const propDescriptor = descriptor;\n  let attribute = '';\n\n  if (!propDescriptor.set) {\n    throw new Error(`@ariaProperty requires a setter for ${name}`);\n  }\n\n\n  // TODO(b/202853219): Remove this check when internal tooling is\n  // compatible\n  // tslint:disable-next-line:no-any bail if applied to internal generated class\n  if ((prototype as any).dispatchWizEvent) {\n    return descriptor;\n  }\n\n  const wrappedDescriptor: PropertyDescriptor = {\n    configurable: true,\n    enumerable: true,\n    set(this: ReactiveElement, value: unknown) {\n      if (attribute === '') {\n        const options = constructor.getPropertyOptions(name);\n        // if attribute is not a string, use `name` instead\n        attribute =\n            typeof options.attribute === 'string' ? options.attribute : name;\n      }\n      if (this.hasAttribute(attribute)) {\n        this.removeAttribute(attribute);\n      }\n      propDescriptor.set!.call(this, value);\n    }\n  };\n\n  if (propDescriptor.get) {\n    wrappedDescriptor.get = function(this: ReactiveElement) {\n      return propDescriptor.get!.call(this);\n    };\n  }\n\n  return wrappedDescriptor;\n}\n\n/**\n * A property decorator proxies an aria attribute to an internal node\n *\n * This decorator is only intended for use with ARIA attributes, such as `role`\n * and `aria-label` due to screenreader needs.\n *\n * Upon first render, `@ariaProperty` will remove the attribute from the host\n * element to prevent screenreaders from reading the host instead of the\n * internal node.\n *\n * This decorator should only be used for non-Symbol public fields decorated\n * with `@property`, or on a setter with an optional getter.\n *\n * @example\n * ```ts\n * class MyElement {\n *   @ariaProperty\n *   @property({ type: String, attribute: 'aria-label' })\n *   ariaLabel!: string;\n * }\n * ```\n * @category Decorator\n * @ExportDecoratedItems\n */\nexport function ariaProperty(\n    protoOrDescriptor: {}, name?: string,\n    // tslint:disable-next-line:no-any any is required as a return type from decorators\n    descriptor?: PropertyDescriptor): any {\n  if (name !== undefined) {\n    return tsDecorator(protoOrDescriptor, name, descriptor);\n  } else {\n    throw new Error('@ariaProperty only supports TypeScript Decorators');\n  }\n}\n"]}